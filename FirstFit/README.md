运行结果
=============
```
(1024 bytes, @0)
(1023 bytes, @1)
(1021 bytes, @3)
(1017 bytes, @7)
(1009 bytes, @15)
(993 bytes, @31)
(961 bytes, @63)
(897 bytes, @127)
(769 bytes, @255)
(513 bytes, @511)
(1 bytes, @1023)
(1 bytes, @0) (1 bytes, @1023)
(3 bytes, @0) (1 bytes, @1023)
(7 bytes, @0) (1 bytes, @1023)
(15 bytes, @0) (1 bytes, @1023)
(31 bytes, @0) (1 bytes, @1023)
(63 bytes, @0) (1 bytes, @1023)
(127 bytes, @0) (1 bytes, @1023)
(255 bytes, @0) (1 bytes, @1023)
(511 bytes, @0) (1 bytes, @1023)
```

解释
=============

第一个数字代表当前块还有多少空闲，第二个数字代表这个块实际内存中的偏移地址（模拟的）

我们运行的步骤是：从1到1024每个二的次方数依次alloc

这样alloc下来，每次都会从最前面找大小足够的块，因此我们剩余的块就依次从实际地址的1，3，7，15等开始，

可以发现，对于每一个输出，第一个数字和第三个数字始终加起来为1024（我们测试的块大小）

其次，每次剩余的起始地址（第三个数字）都是2^x-1这个数字，因此此样例运行正确.
